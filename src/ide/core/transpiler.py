# -*- coding: utf-8 -*-
from .tokenizer import TokenizerRunner, TokenType
from .parser import GumusParser, Program, VarStmt, FunctionStmt, BlockStmt, IfStmt, WhileStmt, PrintStmt, ReturnStmt, ExprStmt, BinaryExpr, UnaryExpr, Literal, Variable, CallExpr, IncludeStmt, BreakStmt, ContinueStmt, TryStmt
from .library_bridge import LibraryBridge

class GumusToPythonTranspiler:
    def __init__(self):
        self.indent_level = 0
        self.output_lines = []
        self.imports = set()
        
        # Native Mapping (GümüşDil -> Python)
        self.builtins = {
            "uzunluk": "len",
            "metin": "str",
            "sayı": "int",
            "girdi": "input",
            "karekök": "math.sqrt", 
            "rastgele": "random.random", 
            "zaman": "time.time",
            "dosya_oku": "open",
            "dosya_yaz": "open",
            "ekle": "append",
            "çık": "exit",
            "aralık": "range",
            "rastgele_sayı": "random.randint",
            "rastgele_ondalık": "random.uniform",
            "bekle": "time.sleep",
            "temizle": "os.system",
            "sistem": "os.system",
            "mutlak": "abs"
        }
        
    def transpile(self, source_code):
        self.output_lines = []
        self.indent_level = 0
        self.imports = set()
        
        try:
            # 1. Tokenize
            tokens = TokenizerRunner.get_tokens(source_code)
            
            # 2. Parse
            parser = GumusParser(tokens)
            ast = parser.parse()
            
            if not ast or not hasattr(ast, 'statements') or not ast.statements:
                return "# Boş program veya parse hatası."
                
            # 3. Headers
            self.emit("# GümüşDil -> Python Transpiler Output")
            self.emit("# Auto-generated by GümüşIDE")
            self.emit("")
            
            # 4. Visit AST
            for stmt in ast.statements:
                self.visit_stmt(stmt)
            
            # 5. Add Imports
            header = []
            if "math." in str(self.output_lines) and "math" not in str(self.imports): header.append("import math")
            if "random." in str(self.output_lines) or "random.randint" in str(self.output_lines):
                 if "random" not in str(self.imports): header.append("import random")
            if "time." in str(self.output_lines) or "time.sleep" in str(self.output_lines):
                 if "time" not in str(self.imports): header.append("import time")
            if "os." in str(self.output_lines) or "os.system" in str(self.output_lines):
                 if "os" not in str(self.imports): header.append("import os")
            
            # Add explicit LibraryBridge imports
            for imp in sorted(list(self.imports)):
                header.append(imp)
            
            final_output = "\n".join(header + [""] + self.output_lines)
            return final_output.strip()
            
        except Exception as e:
            import traceback
            return f"# HATA: Transpilation başarısız oldu.\n# Sebep: {str(e)}\n\n'''\n{traceback.format_exc()}\n'''"

    def emit(self, text):
        indent = "    " * self.indent_level
        self.output_lines.append(f"{indent}{text}")

    # --- Statement Visitors (Produce Side Effects / Lines) ---

    def visit_stmt(self, node):
        if isinstance(node, VarStmt): self.visit_VarStmt(node)
        elif isinstance(node, FunctionStmt): self.visit_FunctionStmt(node)
        elif isinstance(node, BlockStmt): self.visit_BlockStmt(node)
        elif isinstance(node, IfStmt): self.visit_IfStmt(node)
        elif isinstance(node, WhileStmt): self.visit_WhileStmt(node)
        elif isinstance(node, PrintStmt): self.visit_PrintStmt(node)
        elif isinstance(node, ReturnStmt): self.visit_ReturnStmt(node)
        elif isinstance(node, IncludeStmt): self.visit_IncludeStmt(node)
        elif isinstance(node, BreakStmt): self.visit_BreakStmt(node)
        elif isinstance(node, ContinueStmt): self.visit_ContinueStmt(node)
        elif isinstance(node, TryStmt): self.visit_TryStmt(node)
        elif isinstance(node, ExprStmt): self.visit_ExprStmt(node)
        else:
            self.emit(f"# Unknown Statement: {type(node).__name__}")

    def visit_VarStmt(self, node):
        name = node.name.value
        init = "None"
        if node.initializer:
            init = self.visit_expr(node.initializer)
        self.emit(f"{name} = {init}")

    def visit_FunctionStmt(self, node):
        name = node.name.value
        # Params are identifiers (tokens)
        params = ", ".join([p.value for p in node.params])
        
        self.emit(f"def {name}({params}):")
        self.indent_level += 1
        self.visit_BlockStmt(node.body)
        self.indent_level -= 1
        self.emit("") # Empty line after function

    def visit_BlockStmt(self, node):
        if not node.statements:
            self.emit("pass")
            return
            
        for stmt in node.statements:
            self.visit_stmt(stmt)

    def visit_IfStmt(self, node):
        cond = self.visit_expr(node.condition)
        self.emit(f"if {cond}:")
        
        self.indent_level += 1
        # Then branch is a single statement (usually BlockStmt)
        self.visit_stmt(node.then_branch)
        self.indent_level -= 1
        
        if node.else_branch:
            self.emit("else:")
            self.indent_level += 1
            self.visit_stmt(node.else_branch)
            self.indent_level -= 1

    def visit_WhileStmt(self, node):
        cond = self.visit_expr(node.condition)
        self.emit(f"while {cond}:")
        self.indent_level += 1
        self.visit_stmt(node.body)
        self.indent_level -= 1

    def visit_PrintStmt(self, node):
        val = self.visit_expr(node.expression)
        self.emit(f"print({val})")

    def visit_ReturnStmt(self, node):
        if node.value:
            val = self.visit_expr(node.value)
            self.emit(f"return {val}")
        else:
            self.emit("return")

    def visit_ExprStmt(self, node):
        val = self.visit_expr(node.expression)
        self.emit(val)

    def visit_IncludeStmt(self, node):
        import_stmt = LibraryBridge.get_python_import(node.module)
        self.imports.add(import_stmt)

    def visit_BreakStmt(self, node):
        self.emit("break")

    def visit_ContinueStmt(self, node):
        self.emit("continue")

    def visit_TryStmt(self, node):
        self.emit("try:")
        self.indent_level += 1
        self.visit_stmt(node.try_block)
        self.indent_level -= 1
        self.emit("except Exception:")
        self.indent_level += 1
        self.visit_stmt(node.catch_body)
        self.indent_level -= 1

    # --- Expression Visitors (Return Strings) ---

    def visit_expr(self, node):
        if isinstance(node, BinaryExpr): return self.visit_BinaryExpr(node)
        elif isinstance(node, UnaryExpr): return self.visit_UnaryExpr(node)
        elif isinstance(node, Literal): return self.visit_Literal(node)
        elif isinstance(node, Variable): return self.visit_Variable(node)
        elif isinstance(node, CallExpr): return self.visit_CallExpr(node)
        else:
            return f"/* Unknown Expr: {type(node).__name__} */"

    def visit_BinaryExpr(self, node):
        left = self.visit_expr(node.left)
        right = self.visit_expr(node.right)
        op = node.operator.value
        
        # Operator Mapping
        op_map = {
            "ve": "and", "veya": "or",
            "&&": "and", "||": "or",
            "!": "not", # Unary operator caught here? No.
            "=": "==" # Assignment passed as expression? No, parser separates assignment vs equality.
            # But wait, my parser treats = as EQ in equality methods?
            # TokenType.EQ is '='. TokenType.EQEQ is '=='.
            # Usually only '==' is used for comparison.
        }
        
        final_op = op_map.get(op, op)
        return f"{left} {final_op} {right}"

    def visit_UnaryExpr(self, node):
        op = node.operator.value
        right = self.visit_expr(node.right)
        if op == '!': return f"not {right}"
        return f"{op}{right}"

    def visit_Literal(self, node):
        val = node.value
        if val is True: return "True"
        if val is False: return "False"
        if val is None: return "None"
        if isinstance(val, str): return f'"{val}"'
        return str(val)

    def visit_Variable(self, node):
        # Handle keywords that are actually python keywords (e.g. if a var is named 'def')
        return node.name.value

    def visit_CallExpr(self, node):
        callee_name = self.visit_expr(node.callee)
        args_str = [self.visit_expr(arg) for arg in node.args]
        
        # Builtin Mapping
        if callee_name in self.builtins:
            target_func = self.builtins[callee_name]
            
            # Gümüş-Vizyon (Graphics) support
            if callee_name == "daire_çiz":
                return f'print(f"__CANVAS__:daire {{ {args_str[0]} }} {{ {args_str[1]} }} {{ {args_str[2]} }} {{ {args_str[3]} }}")'
            if callee_name == "dikdörtgen_çiz":
                return f'print(f"__CANVAS__:dikdortgen {{ {args_str[0]} }} {{ {args_str[1]} }} {{ {args_str[2]} }} {{ {args_str[3]} }} {{ {args_str[4]} }}")'
            if callee_name == "çizgi_çiz":
                return f'print(f"__CANVAS__:cizgi {{ {args_str[0]} }} {{ {args_str[1]} }} {{ {args_str[2]} }} {{ {args_str[3]} }} {{ {args_str[4]} }} {{ {args_str[5]} }}")'
            if callee_name == "tuval_temizle":
                return 'print("__CANVAS__:temizle")'

            # Robustness: Swap args if they are random range functions
            if target_func in ["random.randint", "random.uniform"] and len(args_str) == 2:
                # Use min/max to ensure correct order
                a, b = args_str[0], args_str[1]
                return f"{target_func}(min({a}, {b}), max({a}, {b}))"
                
            callee_name = target_func
            
        return f"{callee_name}({', '.join(args_str)})"


